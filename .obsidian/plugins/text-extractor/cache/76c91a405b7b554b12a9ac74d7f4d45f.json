{"path":".obsidian/plugins/text-extractor/cache/76c91a405b7b554b12a9ac74d7f4d45f.json","text":"Solid Simulation with Oriented Particles Matthias M¨uller Nuttapong Chentanez NVIDIA PhysX Research Figure 1: Using particles with orientation enables us to simulate a complex model like this monster truck with plastically deforming body, free spinning wheels with soft tires, and high ﬁdelity mesh skinning in real time all with a sparse physical representation. Abstract We propose a new fast and robust method to simulate various types of solid including rigid, plastic and soft bodies as well as one, two and three dimensional structures such as ropes, cloth and volumet- ric objects. The underlying idea is to use oriented particles that store rotation and spin, along with the usual linear attributes, i.e. posi- tion and velocity. This additional information adds substantially to traditional particle methods. First, particles can be represented by anisotropic shapes such as ellipsoids, which approximate surfaces more accurately than spheres. Second, shape matching becomes ro- bust for sparse structures such as chains of particles or even single particles because the undeﬁned degrees of freedom are captured in the rotational states of the particles. Third, the full transformation stored in the particles, including translation and rotation, can be used for robust skinning of graphical meshes and for transforming plastic deformations back into the rest state. CR Categories: I.3.5 [Computer Graphics]: Computational Ge- ometry and Object Modeling—Physically Based Modeling; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism— Animation and Virtual Reality Keywords: oriented particles, shape matching, position based dy- namics Links: DL PDF 1 Introduction Physical simulation of solids has been investigated for more than two decades in computer graphics. In contrast to the computational sciences, computer graphics is more concerned with creating the overall look and feel of objects than the accurate reproduction of their small scale behavior. Also, artists require easy tuning of the physical attributes as well as full control of object behavior. Lately, the trend in solid simulation in computer graphics has been to increase the accuracy of the mathematical models. This typically requires an increase in their complexity. Advantages of using repre- sentations based on continuum mechanics are that object behavior can be controlled using physical parameters such as Young’s mod- ulus, and that the discretization converges toward the continuous solution with increasing mesh resolution. However, in computer games, where robustness and speed are often more essential than accuracy, simpler unconditionally stable geo- metric methods such as position based dynamics (PBD) [M¨uller et al. 2006] can be sufﬁcient to create the desired physical effects. For these reasons we decided to come up with a method that is as simple and as fast as possible, yet able to create the desired vi- sual ﬁdelity required in many computer graphics applications. Our method is based on generalizations of PBD and the shape matching approach [M¨uller et al. 2005]. The novel idea of using oriented par- ticles in connection with shape matching allows us to create com- plex dynamic objects with only a small number of simulation par- ticles. This makes turning a visual mesh into a physical object a simple task which can be performed in just a few minutes. In the ﬁrst part of the paper we will present our research contribu- tions which are • An extension of PBD to handle orientation and angular veloc- ity of particles • A generalized formulation of the shape matching method in- corporating particle orientations. This new formulation guar- antees stability for arbitrary numbers and arrangements of par- ticles. • To leverage the orientation information to (1) approximate shapes by ellipsoids instead of spheres for more accurate col- lision handling and (2) to skin a visual mesh to the simulation nodes. In the second part we will describe our content creation and simula- tion framework, which we developed based on our the new method, along with a variety of scenes demonstrating the versatility of the system. 2 Related Work Formulating a uniﬁed solver for various solid material types has been an active topic in computer graphics in recent years. As a uni- ﬁed model, [Stam 2009] represents solids with simplices of various dimensions. [O’Brien et al. 1997], [Jansson and Vergeest 2003] and [Lenoir and Fonteneau 2004] describe ways to couple deformable and rigid bodies. [Sifakis et al. 2007] use soft and hard binding to transmit forces between different representations. Point-based approaches lend themselves especially well to uniﬁed solid simu- lation. One such method based on continuum mechanics was pro- posed by [M¨uller et al. 2004] and extended later by [Pauly et al. 2005; Gerszewski et al. 2009]. These approaches use moving least squares (MLS) to derive a deformation ﬁeld from particle posi- tions. MLS is only stable if local particle neighborhoods are in non-degenerate conﬁgurations. This problem was ﬁxed by Martin et al. [2010] who introduced the concept of elastons. In addition to the deformation ﬁeld, the elaston approach also stores derivatives. This way, particles in zero, one, two and three-dimensional conﬁgu- rations can be simulated robustly using generalized MLS (GMLS). Their approach was not designed for real-time use. Our goal was to apply a similar idea to the geometric approach of shape matching [M¨uller et al. 2005]. In an analogous way, basic shape matching fails when particles are arranged in singular pat- terns. We ﬁx this by storing orientation information on the particles. The link to the elaston idea and GMLS is that orientations can be viewed as derivative information of a normalized deformation ﬁeld. An oriented particle is basically the simplest piece of information to ﬁx the singularity problem. Due to its simplicity, the oriented particle approach is signiﬁcantly faster then using elastons. [Becker et al. 2009] use particles in connection with SPH-based forces to simulate various solids. They solve the singularity prob- lem of degenerate cases by stabilizing the polar decomposition as in [Schmedding and Teschner 2008]. The missing rotation informa- tion is completed statically and not simulated as in our case. In the extreme case of a single particle, for instance, stabilized polar de- composition always returns the identity matrix for the particle’s ori- entation, while in our case the angular quantities evolve physically in time. Another problem arises when exactly two Eigenvalues of the moment matrix are zero. This happens permanently for one- dimensional structures with stretched rest state. While one missing Eigenvector can be determined uniquely using the cross product of the other two, the directions of two missing Eigenvectors are not unique. To avoid jittering, they need to be chosen consistently over time which is only possible with a state variable. This is exactly what our orientation information on the particles provides. The problems of simulating one, two and three-dimensional solids have been studied independently as well. To mention only a few pa- pers, [Pai 2002] simulates elastic rods such as hair, wire and threads using the Cosserat theory by formulating a Boundary Value Prob- lem (BVP) which does not have a guaranteed running time bound in general. [Bertails et al. 2006] and [Spillmann and Teschner 2007; Bertails 2009] reduced the complexity of the approach to be quadratic and linear in time, respectively. An approach based on discrete differential geometry was proposed by [Bergou et al. 2010] to allow for simulating thin viscous liquid threads like drip- ping honey. The simulation of thin deformable bodies has been an active re- search ﬁeld as well. [Provot 1995] were among the ﬁrst to use mass- spring networks for simulating cloth. Later [Baraff and Witkin 1998] and [Bridson et al. 2003] proposed to use semi-implicit inte- gration to increase stability and allow for larger time steps. [Volino et al. 2009] used non-linear springs to capture cloth behavior more faithfully. Various authors have addressed the problem of cloth stretchiness using the idea of strain limiting such as [Goldenthal et al. 2007]. Beside cloth simulation [Grinspun et al. 2003] and many others investigated the more general problem of thin shell simulation. In computer graphics one of the most popular approach to simu- lating volumetric solids is the Finite Element Method (FEM) with linear tetrahedral elements. This technique was used in [O’Brien and Hodgins 1999] to simulate fracture and by [O’Brien et al. 2002; Bargteil et al. 2007; Wojtan and Turk 2008] to model plastic mate- rials. The co-rotational formulation was introduced by [M¨uller and Gross 2004] to reduce visual artifacts in connection with linear el- ements and large deformations. To reduce the number of elements required for simulation Martin et al. [2008] generalized the tradi- tional method to include general polyhedral elements. The idea of attaching orientation information to particles and the term ”oriented particle” was introduced by [Szeliski and Tonnesen 1992]. They used the additional information to deﬁne special en- ergy potentials that let non-connected particles form surfaces rather then volumetric objects. Their approach is quite different from ours since they do not use a mesh, their particles are isotropic, they do not handle collision detection nor use the particles for skinning a visual mesh. 3 Generalized Shape Matching As mentioned previously, the main idea behind our approach is to use particles that have both position and orientation. We will ﬁrst show how the shape matching approach [M¨uller et al. 2005] beneﬁts from this additional piece of information because shape matching lies at the core of our method. Given n particles with rest position ¯xi, current position xi and mass mi we are looking for a global translation t and rotation R of the rest state that matches the current positions optimally in a least squares sense. For this the moment matrix A has to be computed as A = ∑ i mi(xi − c)(¯xi − ¯c) T ∈ R3×3, (1) where the mass centers are deﬁned as c = ∑ i mixi/∑ i mi and (2) ¯c = ∑ i mi ¯xi/∑ i mi. (3) The polar decomposition A = RS yields the least squares optimal rotation R of the original shape into the actual conﬁguration while for the translation we have t = c − ¯c. Using this transformation, the goal position of each particle becomes gi = R(¯xi − ¯c) + c. (4) If the particles are close to co-planar or co-linear, A becomes ill- conditioned or even singular. In this case, the optimal rotation R is not well deﬁned, causing the simulation to be unstable. This problem can be ﬁxed by using the orientation information of the particles. Let us assume we have two groups of particles with their respective moment matrices A1 and A2. To compute the total moment matrix A of the union of the particles, the two matrices cannot simply be added because each one is computed w.r.t. its own center of mass. Fortunately there is an easy way to ﬁx this problem. In their paper, [Rivers and James 2007] reformulated Eq. (1) for fast summation into the following form: A = ∑ i mixi ¯x T i − Mc¯c T , (5) where M = ∑i mi. Now let us assume we could deﬁne a moment matrix Ai for a single particle w.r.t. its center of mass xi. Using Eq. (5) we shift the center of mass of each Ai to the global one as A = ∑ i ( Ai + mixi ¯xT i − mic¯c T ) (6) and Eq. (1) generalizes to A = ∑ i ( Ai + mixi ¯x T i ) − Mc¯c T (7) To compute the moment matrix of a particle with orthonormal ori- entation matrix R we integrate Eq. (1) over the particle’s volume yielding Asphere = ∫ Vr ρ(Rx)xT dV = ρR ∫ Vr xx T dV (8) = 4 15 πr5ρR = 4 15 πr5 m Vr R = 1 5 mr2R for a sphere, where Vr is the volume of a sphere of radius r. For an ellipsoid with radii a, b and c we get Aellipsoid = 1 5 m   a2 0 0 0 b2 0 0 0 c2   R (9) With this extension we always get a full rank moment matrix A even for a single particle! Eq. (7) can be viewed as a specialized version of GMLS [Martin et al. 2010] for the case that the deformation derivatives only contain rotations. However, in contrast to GMLS, Eq. (7) takes into consideration particles of ﬁnite size through the integral in Eq. (8) instead of single points only. 4 Generalized Position Based Dynamics Before describing our overall simulation model, we explain how to evolve oriented particles in time. As an integration scheme we use PBD because shape matching is designed to work with this ap- proach. To handle the rotational quantities we had to generalize PBD. We will brieﬂy recap basic position based dynamics and then ex- plain our generalization. PBD evolves a set of particles with po- sitions x and velocities v in three stages per time step. In the pre- diction stage a predicted position xp is computed for each particle using explicit Euler integration so xp ← x + v∆t. In the second stage, the solver corrects the predicted positions (not the velocities, thus the name of the method) such that they satisfy a set of con- straints by iterating through all constraints multiple times. Finally the particles’ state variables are updated in the integration step as v ← (xp − x)/∆t and x ← xp. Note that the solver’s modiﬁcations on the predicted positions inﬂuence the velocities of the particles. Only this way does the resulting system become second order in time. PBD is straight forward to implement yet unconditionally stable because positional corrections never overshoot. As in regular PBD, we deﬁne stiffness, friction and damping coef- ﬁcients to be scalars s ∈ [0 . . . 1]. Since we use constant time steps, this deﬁnition is intuitive and works as expected. However, if the time steps are not constant, the coefﬁcients should be deﬁned as s = s′∆t to reduce time step size dependence. 4.1 Integration In addition to position x and velocity v, our particles carry an orien- tation unit quaternion q and the angular velocity ω. The prediction step using explicit forward Euler integration then becomes xp ← x + v∆t (10) qp ← [ ω |ω| sin( |ω|∆t 2 ), cos( |ω|∆t 2 ) ] q, (11) For stability reasons, qp should directly be set to q if |ω| < ε. Af- ter the solver has modiﬁed the predicted state (xp, qp), as we shall describe in Section 5.1, the current state is updated using the inte- gration scheme v ← (xp − x)/∆t (12) x ← xp (13) ω ← axis(qpq−1) · angle(qpq−1)/∆t (14) q ← qp, (15) where axis() returns the normalized direction of a quaternion and angle() its angle. Again, for stability reasons, ω should be set to zero directly if |angle(qpq−1)| < ε. There are two rotations, r = qpq−1 and −r transforming q into qp. It is important to always choose the shorter one, i.e. if r.w < 0 use −r. As in traditional PBD for translation, changing the rotational quantity qp in the solver also affects its time derivate ω through the integration step creating the required second order effect. Note that this formulation is a simpli- ﬁcation of the true rigid body dynamics since it omits precession. The error introduced is zero for spherical particles and grows with the aspect ratio of the particle shape. Also, correct precession of bodies composed of multiple particles emerges automatically so the error shows only for bodies composed of a small number of parti- cles. 4.2 Friction In PBD, friction is handled by scaling down the linear velocity by a constant factor s after the update step. If a particle has collided with a solid object, we modify both, linear and angular velocities as v ← v + (vs − v)⊥n · slin (16) ω ← ω + r |r|2 × (vs − v − ω × r) · srot , (17) where vs and n are the velocity and the normal of the solid at the impact point, r = r n and r is the particle radius. The two scalars slin ∈ [0 . . . 1] and srot ∈ [0 . . . 1] control the amount of linear and angular friction. The equations for handling friction in case of two particles colliding with each other look similar v1 ← v1 + ( v1 + v2 2 − v1)⊥n · slin (18) v2 ← v2 + ( v1 + v2 2 − v2)⊥n · slin (19) and ω1 ← ω1 + r1 |r1|2 × (vavg − v1 − ω1 × r1) · srot (20) ω2 ← ω2 + r2 |r2|2 × (vavg − v2 − ω2 × r2) · srot (21) where in this case n = (x2 − x1)/|x2 − x1|, r1 = rn, r2 = −rn and vavg = (v1 + ω1 × r1 + v2 + ω2 × r2)/2. 5 Simulation Model We represent objects as a set of oriented particles and a set of edges connecting them. The resulting mesh does not need to have the topology of a triangle or tetrahedral mesh. It might look similar to a tetrahedral mesh locally in places where the model is volumetric. In other locations, where thin structures are present, it can take the form of a particle chain as in Fig. 3(d). 5.1 Implicit Shape Matching This data structure is simulated by deﬁning one shape matching group per particle. A group contains the corresponding particle and all the particles connected to it via a single edge. In sparse regions of the mesh, regular shape matching would become immediately unstable in this setting while in our case there are no limitations to the connectivity structure. After the prediction step, the solver iterates multiple times through all shape match constraints in a Gauss-Seidel type fashion. For each constraint the goal positions are computed using Eq. (4). All the particles of the group are then moved towards their goal position by the same fraction sstiffness which mimics stiffness as in [M¨uller et al. 2006]. This stiffness can be speciﬁed per particle as Fig. 3(c) shows. In terms of orientation, we only update the orientation of the center particle by replacing it with the optimal rotation provided by shape matching. Generalized shape matching, as we formulated it in Sec- tion 3, has a nice property: it only inﬂuences the orientation of the particle along the directions contained in the moment matrix A. Let us have a look at two extreme cases. If there is only one particle in the group, generalized shape matching will return the orientation of that particle (see Eq. (7)) so the solver does not change it as ex- pected. If the number of particles in the group and their positions are such that they robustly span a 3D space, the new orientation of the particle is dominated by the orientation of the entire group. All situations in between smoothly interpolate these two cases. In case of a chain of particles, for instance, the orientations of the particles along the direction of the chain are determined by shape matching, while they can freely rotate about the axis along the chain. 5.2 Stretching vs. Bending Shape matching per node models both stretching and bending resis- tance at the same time. This is sufﬁcient in many cases. If the artist wishes to specify them separately, we support regular PBD distance constraints on the edges as well. So in order to reduce bending resistance only, the shape match stiffness can be made small and the distance constraints activated. However, if the shape matching stiffness is set to zero, shape matching still has to be performed to update the orientations of the particles for collisions and skinning since the distance constraints only act on the positions. 5.3 Explicit Shape Matching We also support additional explicit shape matching groups deﬁned by the user which can cover arbitrary subsets of the particles in the mesh. The implicit shape matching as described above is not per- formed for particles in explicit groups. Their positions and orien- tations are controlled by the explicit group only. In contrast to im- plicit shape matching, all participating particles get the shape match rotation. This results in rigid components, as shown in several ex- amples in Section 9. There is one exception: particles belonging to more than one explicit shape matching group are treated as non- oriented (i.e. the matrix Ai in Eq. (7) is set to zero for particle i). This allows us to model various joints as in the monster truck sam- ple. Without this exception rotation information would propagate from one group to the other and prevent the wheels from rotating freely. 5.4 Plastic Deformation We allow the explicit shape matching groups to deform plastically as well. Plastic deformation starts whenever one of the group par- ticles is involved in a collision with relative velocity higher than a user deﬁned threshold. When this happens, we simply deactivate the shape matching group for a ﬁxed number of simulation frames (5 in our case) and let implicit shape matching take over. After the deformation phase, we reactivate the explicit group and absorb the deformation into the rest state. Special care has to be taken when updating the rest state. It is cru- cial that explicit shape matching groups do not store individual rest positions of particles. The rest conﬁguration of the model needs to be consistent over all shape matching groups otherwise ghost forces appear. Also, when distorting the rest poses, the original poses are still needed. We call these original poses the bind poses. Let bi, ri and di be rigid transformations of the form f (x) = Rx + t, where R is a rotation matrix. The bind pose transformations bi map a zero centered and axis aligned particle to its original position and orientation deﬁned by the user and the algorithm we will describe in Section 6.2. Before plastic deformation occurs, the rest poses ri correspond to the bind poses so ∀i : ri = bi. The transformations di map the particles from the rest pose to the current pose and, thus, describe the deformation of the object. These are the transforma- tions that shape matching gives us. Without plastic deformation, they can directly be used for mesh skinning (see Section 7). How- ever, as soon as the rest poses do not correspond to the bind poses anymore, the transformations to be used for skinning are di ◦ri ◦b −1 i (application from right to left). In contrast, the poses of the particles for collision detection are di ◦ ri. After the deformation phase, particle i deviates from the rest pose ri. This deviation is stored in the transformation di. We want to absorb this transformation by changing the rest pose ri. However, since the object in world space is not aligned with the rest state during the simulation, the world space deformation di needs to be transformed back into the rest state space before being absorbed. Since the transformation from rest to world space varies over the object, we have to pick a speciﬁc one and choose the transformation s returned by the shape matching group at the ﬁrst frame after re- activation. At this point in time we let ri ← s−1 ◦ di ◦ ri. 5.5 Torsion Resistance To control torsion resistance we iterate through all the edges and update the rotations of the adjacent particles similar to friction han- dling as q1 ←slerp ( q1, q2, 1 2 storsion ) (22) q2 ←slerp ( q2, q1, 1 2 storsion ) . (23) The function slerp(q1, q2, s) returns q1 if s = 0, q2 if s = 1 and the spherical interpolation of q1 and q2 for values in between. 6 Collision Handling In traditional PBD particles are represented by spheres. Using these spheres as collision primitives results in bumpy collision represen- tations of objects. This is problematic because bumpy surfaces in- troduce unnatural friction and other visual artifacts. The fact that our particles have orientation information lets us represent them by ellipsoids which can more accurately approximate ﬂat surfaces, as demonstrated in [Yu and Turk 2010] in the case of ﬂuid simulations (see Fig. 3(c)). Two questions arise. First, how to handle ellipsoids correctly in the collision detection step and, second, how to ﬁnd their principal radii prior to the simulation. 6.1 Ellipsoid Collision When using spheres, a collision with a plane occurs when the par- ticle gets closer to the plane than its radius r. In this case, PBD shifts the particle up along the plane normal n such that it touches the plane as shown in Fig. 2(a). For an ellipsoid the situation gets a bit more complicated. A simple approximate way to resolve the collision is to use the ellipse’s radius in the direction of n for col- lision handling. As Fig. 2(b) shows, the collision is only resolved correctly if n is aligned with the principal axes of the ellipsoid. In Appendix A.1 we show how to compute the correct distance d shown in Fig. 2(c). This is slightly more expensive. The situation is similar in the case of particle-particle collisions shown in Fig. 2(d)- (f) for which we derive the necessary equations in Appendix A.2. 6.2 Ellipsoid Representation of Objects Let us assume the user has already placed the particles to simulate a given graphical mesh and speciﬁed radii for each of them. We use the same radius for all particles depending on the spacing of the particles to be able to use spatial hashing [Teschner et al. 2003] effectively for ﬁnding overlapping particles. We now wish to automatically compute the principal axis direc- tions and radii for each particle. Our algorithm to do this is sim- ilar to the method proposed in [Yu and Turk 2010] for creating smooth surfaces of particle ﬂuids. For a certain particle we collect all graphical vertices within the particle’s radius. We then compute the co-variance matrix of this vertex cloud relative to the particle’s center and use polar decomposition to determine the orientation of the ellipsoid. In contrast to [Yu and Turk 2010] we do not use the eigenvalues of the co-variance matrix to determine the radii of the ellipsoid because the eigenvalues are related to the sum of squared distances and not the distances themselves. Instead, we use the ex- tents of the oriented bounding box (OBB) of the mesh vertices as principal radii. For stability reasons we clamp the radii to the range [ 1 σ r . . . r], where σ is a limit on the aspect radio. In our examples we use σ = 2. nn n r R dRn rn nn n r drn (a) (b) (c) (d) (e) (f) Figure 2: Rows: particle-plane collision, particle-particle colli- sion. Left to right: sphere collision, approximate and correct ellip- soid collision This approach can be extended in a useful way. Instead of adjusting only the orientations of particles, one can also move them to the center of mass of the surrounding vertices. By iterating these two steps multiple times, particles placed on the surface of the graphical mesh typically drift towards the center of a feature such as an arm. We used this property to create the skeleton shown in Fig. 3(c). 7 Visual Mesh Skinning A common method to animate an arbitrary graphical mesh is to embed it in a tetrahedral simulation mesh as in [M¨uller and Gross 2004]. While the tetrahedral mesh deforms, each graphical vertex is transformed along with it, using barycentric weighting of the ver- tex positions of the closest tetrahedron. The method is only robust if each graphical vertex is surrounded by a tetrahedron because only in that case all the barycentric coordinates are positive, as noticed by [Twigg and Kacic-Alesic 2010]. Many tetrahedra are typically required to get an accurate approximation of the graphical mesh’s surface, particularly if the graphical mesh has a complex structure with many branches that need to be resolved in order to move inde- pendently. The fact that, in our case, each particle stores a full transformation composed of translation and rotation from the rest state to the cur- rent state lets us use a more robust approach for binding the graph- ical to the simulation particles. For each graphical vertex we pre- compute links and weights to nearby particles (at most 4 in our case) and use linear blend skinning to compute its transformation. This yields plausible deformations even if the visual geometry is far away from the simulated particles and for very sparse simula- tion meshes. Skinning remains well deﬁned for the case even of a single simulation particle. We found that simple linear blend skin- ning was sufﬁcient. However, to further improve the results, dual quaternion blending [Kavan et al. 2008] could be used as well. 8 Simulation Framework We built a design and simulation framework to create various demo scenes. The design tool is used to create a physical representa- tion of an object. After loading a graphical mesh, the user places Figure 4: This underwater scene with a lion ﬁsh and six plants demonstrates simulation and collision handling of thin features. multiple simulation particles on the mesh surface with a spray tool. Alternatively, particles can also be placed individually for more pre- cise control. Next, with an additional spray tool, edges are gener- ated within the tool’s radius between particles that are closer than a speciﬁed distance. Edges can also be deﬁned individually. After creating the skinning weights automatically, the model can already be simulated as a preview in the editor. There are other tools to paint node and torsion stiffnesses; to deﬁne explicit shape match- ing groups; to adjust skinning weights; and to automatically ﬁt el- lipsoids. While creating the physical model only takes a few minutes, paint- ing the skinning weights is often tedious. The difﬁcult part is to make sure vertices are not linked to particles belonging to other in- dependently moving parts of the object like another tentacle of the octopus shown in Fig. 3. There is a simple way to ﬁx this problem in our tool. The user ﬁrst selects a subset of the simulation par- ticles for instance all the particles on one tentacle. Then the user selects a subset of the graphical vertices. The skinning tool then creates links for the selected vertices only and binds them only to selected simulation particles. This step is repeated until all vertices are linked. 9 Results All our examples were executed in real time on a single core of an Intel Core2 CPU at 2.4 GHz and an NVIDIA Quadro FX 5800 GPU. Although we are working on a GPU version of the solver we list CPU ﬁgures here to demonstrate that the method is fast even if run sequentially. Fig. 3 shows how a physical model is created from a graphical mesh using our framework. First, nodes were painted using the spray tool with a speciﬁed distribution density. The auto ellipsoid tool gen- erated the orientations and shapes of the ellipsoids automatically. The user has painted per particle stiffness parameters shown in col- ors from 0 (green) to 1 (red). The edge spray tool was then used to create edges with a certain maximal length. As Fig. 3(d) shows, the tips of the tentacles are one dimensional particle chains. Near the head the mesh has the form of a triangulated surface, while further down it ﬁlls space and looks more like a tetrahedral mesh. The simulation mesh consists of 300 particles and 750 edges, while the visual mesh has 5k vertices and and 10k triangles. Simulating this model including self collision handling takes 4ms, and skinning and rendering 6ms. For three instances interacting with each other as shown in Fig. 3(f) the solver takes 10ms. Figure 5: Two monster trucks colliding. The lower car’s autobody deforms plastically during the crash. Figure 6: Left: A rope represented by a chain of ellipsoids with orientation information. Right: Six times more non oriented spher- ical particles are needed to capture the twist dynamics and to get a collision volume of comparable accuracy. Figure 3: Model creation. From top left to bottom right: (a) Original graphical mesh, (b) particles created with spray tool, (c) ellipsoid ﬁt and stiffness painted, (d) edges created with spray tool, (e) soft deformation, (f) complex collisions and interaction. Fig. 4 shows an underwater scene with a lion ﬁsh and six plants. Buoyancy forces are applied to plant nodes. As initial condition we added random impulses to the plant leaves to break visual similarity in the ﬁrst frame. Only the ﬁsh’s head motion is scripted. All other dynamic effects are a results of the simulation. There are a total of 1k particles with 3.5k edges while the the visual mesh has a total of 30k vertices and 48k triangles. The solver and skinning take 10ms and 9ms, respectively. Since our method is conceptually most closely related to the elaston approach [Martin et al. 2010], we created this scene to compare our method to their lion ﬁsh sample. The authors report a total com- putational cost of 7s per frame. We are, thus, about three orders of magnitude faster with more visual degrees of freedom on the ﬁsh and interaction with complex plants. From a pure computation point of view, this comparison is not fair since we only use 1k par- ticles in total versus 5k elastons. However, for computer graphics applications, it is the visual result that is most relevant. If that can be achieved with a much simpler model, the direct comparison is justiﬁed. The monster truck visual mesh shown in Fig. 1 and Fig. 5 is com- posed of 63k vertices and 100k triangles. The model we use to simulate it contains only 300 particles and 800 edges. Due to this setup, skinning is the bottleneck in these scenes. Simulating the two interacting trucks in Fig. 5 and skinning the meshes takes 8ms and 30ms respectively. With rendering, the scene still runs at the interactive rate of 20 fps. We achieved the effect of free spinning wheels by creating three explicit shape matching groups, one for the autobody and one for each axle. Since the autobody group shares exactly two particles with each of the axle groups, there remains one degree of freedom for each axle too rotate freely. The advantage of our approach in terms of model and time com- plexity over traditional shape matching and the SPH-based ap- proach of [Becker et al. 2009] is depicted in Fig. 6. On the left a rope is represented by a chain of ellipsoidal particles with ori- entation. The edge structure is the simple string shown in blue. To capture the twist dynamics and to get a collision volume of comparable accuracy, six times more regular spherical particles are needed. Again, the edge structure is shown in blue. This time each cross section is composed of three connected particles such that the orientation of the rope can be represented by the locations of the particles alone. To avoid gaps in the collision volume the number of segments has to be doubled yielding six times more particles and twelve times more edges. Since the running time is dominated by per particle shape matching and the cost of integrating orientation information is negligible, our method is about six times faster then traditional shape matching in this scenario. 10 Conclusion and Future Work We have presented a novel method based on shape matching to sim- ulate various types of solid using only a small number of particles connected by meshes with arbitrary topology. The key idea to make shape matching work in sparse regions of the mesh is to add orien- tation and rotation information to the particles. This information can also be used to create more accurate collision volumes as well as skinning graphical meshes to the physical model. Our content creation editor enables artists to create versatile physical models in a matter of minutes from any visual mesh. Being a geometric approach, our model has its disadvantages as well. It is hard to make the simulation time step independent if variable time steps are required. Also, the physical behavior is de- pendent on the mesh geometry and does not converge to a certain solution with mesh reﬁnement as models based on continuum me- chanics. This is not a big issue unless one would want to auto- generate models of various resolutions for run time level of detail. This is an interesting problem for further research. The two main bottlenecks are currently shape matching and skin- ning of the visual mesh. We are in the process of writing a parallel, GPU accelerated version of our solver. Also, having focussed on solids only so far, a next step would be to study the interaction of solids with ﬂuids in a uniﬁed framework. Acknowledgements We thank NVIDIA for supporting our research and the PhysX team, especially Gordon Yeoman, for the valuable inputs and feedback. References BARAFF, D., AND WITKIN, A. 1998. Large steps in cloth simula- tion. Proceedings of ACM Siggraph, 43–54. BARGTEIL, A. W., WOJTAN, C., HODGINS, J. K., AND TURK, G. 2007. A ﬁnite element method for animating large viscoplas- tic ﬂow. ACM Transactions on Graphics 26, 3 (July), 16:1–16:8. BECKER, M., IHMSEN, M., AND TESCHNER, M. 2009. Corotated sph for deformable solids. In Eurographics Workshop on Natural Phenomena, 27–34. BERGOU, M., AUDOLY, B., VOUGA, E., WARDETZKY, M., AND GRINSPUN, E. 2010. Discrete Viscous Threads. SIGGRAPH (ACM Transactions on Graphics). BERTAILS, F., AUDOLY, B., CANI, M.-P., QUERLEUX, B., LEROY, F., AND L ´EV ˆEQUE, J.-L. 2006. Super-helices for predicting the dynamics of natural hair. ACM Transaction on Graphics 25, 3 (July), 1180–1187. BERTAILS, F. 2009. Linear time super-helices. Computer Graphics Forum 28, 2 (Apr.), 417–426. BRIDSON, R., MARINO, S., AND FEDKIW, R. 2003. Simula- tion of clothing with folds and wrinkles. In ACM SIGGRAPH Symposium on Computer Animation, 28–36. GERSZEWSKI, D., BHATTACHARYA, H., AND BARGTEIL, A. W. 2009. A point-based method for animating elastoplastic solids. In Proceedings of the 2009 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, ACM, New York, NY, USA, SCA ’09, 133–138. GOLDENTHAL, R., HARMON, D., FATTAL, R., BERCOVIER, M., AND GRINSPUN, E. 2007. Efﬁcient Simulation of Inextensible Cloth. SIGGRAPH ( ACM Transactions on Graphics) 26, 3. GRINSPUN, E., HIRANI, A. N., DESBRUN, M., AND SCHR ¨ODER, P. 2003. Discrete shells. In Proceedings of the 2003 ACM SIG- GRAPH/Eurographics symposium on Computer animation, Eu- rographics Association, Aire-la-Ville, Switzerland, Switzerland, SCA ’03, 62–67. JANSSON, J., AND VERGEEST, J. S. M. 2003. Combining deformable- and rigid-body mechanics simulation. In In The Vi- sual Computer, SpringerVerlag, 280–290. KAVAN, L., COLLINS, S., ZARA, J., AND O’SULLIVAN, C. 2008. Geometric skinning with approximate dual quaternion blending. ACM Press, New York, NY, USA, vol. 27, 105. LENOIR, J., AND FONTENEAU, S. 2004. Mixing deformable and rigid-body mechanics simulation. In Proceedings of the Com- puter Graphics International, IEEE Computer Society, Wash- ington, DC, USA, 327–334. MARTIN, S., KAUFMANN, P., BOTSCH, M., WICKE, M., AND GROSS, M. 2008. Polyhedral ﬁnite elements using harmonic basis functions. Computer Graphics Forum 27, 5, 1521–1529. MARTIN, S., KAUFMANN, P., BOTSCH, M., GRINSPUN, E., AND GROSS, M. 2010. Uniﬁed simulation of elastic rods, shells, and solids. ACM Trans. on Graphics (Proc. SIGGRAPH) 29, 3, 39:1– 39:10. M ¨ULLER, M., AND GROSS, M. H. 2004. Interactive virtual mate- rials. In Graphics Interface 2004, 239–246. M ¨ULLER, M., KEISER, R., NEALEN, A., PAULY, M., GROSS, M., AND ALEXA, M. 2004. Point based animation of elastic, plastic and melting objects. In the ACM SIGGRAPH 2004 Sym- posium on Computer Animation, 141–151. M ¨ULLER, M., HEIDELBERGER, B., AND TESCHNER, M. 2005. Meshless deformations based on shape matching. In Proc. SIG- GRAPH 2005, 471–478. M ¨ULLER, M., HENNIX, B. H. M., AND RATCLIFF, J. 2006. Posi- tion based dynamics. Proceedings of Virtual Reality Interactions and Physical Simulations, 71–80. O’BRIEN, J. F., AND HODGINS, J. K. 1999. Graphical modeling and animation of brittle fracture. In Computer Graphics (SIG- GRAPH ’99 Proceedings), ACM Press, New York, 137–146. O’BRIEN, J. F., ZORDAN, V. B., AND HODGINS, J. K. 1997. Combining active and passive simulations for secondary motion. In Proceedings of SIGGRAPH 1997, Technical Sketch. O’BRIEN, J. F., BARGTEIL, A. W., AND HODGINS, J. K. 2002. Graphical modeling and animation of ductile fracture. In Com- puter Graphics (SIGGRAPH 2002 Proceedings), 291–294. PAI, D. K. 2002. STRANDS: Interactive simulation of thin solids using Cosserat models. Computer Graphics Forum 21, 3 (Sept.), 347–352. PAULY, M., KEISER, R., ADAMS, B., DUTR ´E, P., GROSS, M., AND GUIBAS, L. J. 2005. Meshless animation of fracturing solids. ACM Trans. Graph. 24 (July), 957–964. PROVOT, X. 1995. Deformation constraints in a mass-spring model to describe rigid cloth behavior. Proceedings of Graphics Inter- face, 147–154. RIVERS, A. R., AND JAMES, D. L. 2007. Fastlsm: Fast lat- tice shape matching for robust real-time deformation. In ACM Transactions on Graphics (Proc. SIGGRAPH 2007), vol. 26(3), 82:1–82:6. SCHMEDDING, R., AND TESCHNER, M. 2008. Inversion han- dling for stable deformable modeling. In The Visual Computer, vol. 24, 625–633. SIFAKIS, E., SHINAR, T., IRVING, G., AND FEDKIW, R. 2007. Hybrid simulation of deformable solids. In Proceedings of the 2007 Symposium on Computer Animation, 81–90. SPILLMANN, J., AND TESCHNER, M. 2007. CORDE: Cosserat rod elements for the dynamic simulation of one-dimensional elastic objects. In Proceedings of the 2007 Symposium on Com- puter Animation, Eurographics Association, 63–72. STAM, J. 2009. Nucleus: Towards a uni?ed dynamics solver for computer graphics. In In IEEE International Conference on Computer-Aided Design and Computer Graphics, 1–11. SZELISKI, R., AND TONNESEN, D. 1992. Surface modeling with oriented particle systems. SIGGRAPH Comput. Graph. 26 (July), 185–194. TESCHNER, M., HEIDELBERGER, B., M ¨ULLER, M., POMERAN- ERTS, D., AND GROSS, M. 2003. Optimized spatial hashing for collision detection of deformable objects. Proc. Vision, Model- ing, Visualization VMV 2003, 47–54. TWIGG, C., AND KACIC-ALESIC, Z. 2010. Point cloud glue: Constraining simulations using the procrustes transform. ACM SIGGRAPH/Eurographics Symposium on Computer Animation. VOLINO, P., MAGNENAT-THALMANN, N., AND FAURE, F. 2009. A simple approach to nonlinear tensile stiffness for accurate cloth simulation. ACM Trans. Graph. 28 (September), 105:1– 105:16. WOJTAN, C., AND TURK, G. 2008. Fast viscoelastic behavior with thin features. ACM Transactions on Graphics 27, 3 (Aug.), 47:1–47:8. YU, J., AND TURK, G. 2010. Reconstructing surfaces of particle-based ﬂuids using anisotropic kernels. ACM SIG- GRAPH/Eurographics Symposium on Computer Animation. A Appendix A.1 Ellipsoid-Plane Collision Given are an ellipsoid centered at the origin with principal radii a, b, c and orientation R and a plane p as nT x = d. To resolve a potential collision we ﬁrst compute the contact point which is the point on the ellipsoid with normal parallel to n, i.e. to which p is tangent. The ellipsoid can be deﬁned as the zero iso-surface of c(x) = x T Ax − 1, (24) where A = R   1 a2 0 0 0 1 b2 0 0 0 1 c2   RT and A−1 = R   a2 0 0 0 b2 0 0 0 c2   RT . (25) The point x we are looking for meets the two constraints ∇c(x) = λ n and (26) c(x) = 0 (27) With ∇c(x) = 2Ax we solve the ﬁrst constraint for x yielding x = 1 2 A−1λ n. Substituting into the second constraint and solving for λ gives λ = ± 2 √ nT A−1n and so x = ± A−1n √ nT A−1n . (28) The solution for which nT x is smaller is the contact point. If this point is below the plane, i.e. nT x < d there is a collision. A.2 Ellipsoid-Ellipsoid Collision Let us assume we have two ellipsoids, both with their center at the origin and we want to separate them by moving ellipsoid 2 along the direction deﬁned by the normal vector n. For the two ellipsoids we have the constraint functions c1(x) = x T A1x − 1 and (29) c2(x) = (x − dn) T A2(x − dn) − 1. (30) We are looking for two scalars d and λ and a contact point x such that c1(x) = 0 (31) c2(x) = 0 (32) ∇c1(x) = λ ∇c2(x). (33) The scalar d will tell us how far to shift ellipsoid 2 from the origin along n such that the two ellipsoids touch (from outside if λ < 0). Expanding the third constraint yields A1x = λ A2(x − dn). (34) Solving for x gives x = (λ A2 − A1) −1A2λ dn. (35) Setting B = (λ A2 − A1)−1A2, noting that the Ai are symmetric and substituting into the ﬁrst and second constraint results in two equations for λ and d: λ 2n T BT A1B n = 1 d2 (36) n T (λ B − I) T A2(λ B − I)n = 1 d2 (37) Now we equate the two left hand sides and multiply with (BT )−1 from the left and with B−1 from the right on both sides resulting in λ 2nT A1n = n T (λ I − B −1) T A2(λ I − B −1)n (38) Back substituting B, the right hand side becomes nT [ λ I − A−1 2 (λ A2 − A1) ]T A2 [ λ I − A−1 2 (λ A2 − A1) ] n. (39) Most of the terms cancel out and we are left with the very simple expression λ = ± √ nT A1A−1 2 n. (40) Once λ is known Eq. (36) can be used to compute d and Eq. (35) to evaluate x. In terms of signs, we want λ to be negative (ellipsoids touching from the outside) and d to be positive (shifting ellipsoid 2 in the positive direction of n.","libVersion":"0.2.2","langs":""}