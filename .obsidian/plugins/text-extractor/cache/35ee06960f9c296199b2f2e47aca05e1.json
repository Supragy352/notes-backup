{"path":".obsidian/plugins/text-extractor/cache/35ee06960f9c296199b2f2e47aca05e1.json","text":"ACM SIGGRAPH / Eurographics Symposium on Computer Animation 2020 J. Bender and T. Popa (Guest Editors) Volume 39 (2020), Number 8 Detailed Rigid Body Simulation with Extended Position Based Dynamics Matthias MÃ¼ller1 Miles Macklin1,2 Nuttapong Chentanez1 Stefan Jeschke1 Tae-Yong Kim1 1NVIDIA 2University of Copenhagen Figure 1: Our method allows the stable simulation of a rolling ball sculpture with fast moving marbles and collisions against curved geometry as well as a remote controlled car racing over obstacles with deformable tires. Abstract We present a rigid body simulation method that can resolve small temporal and spatial details by using a quasi explicit integra- tion scheme that is unconditionally stable. Traditional rigid body simulators linearize constraints because they operate on the velocity level or solve the equations of motion implicitly thereby freezing the constraint directions for multiple iterations. Our method always works with the most recent constraint directions. This allows us to trace high speed motion of objects colliding against curved geometry, to reduce the number of constraints, to increase the robustness of the simulation, and to simplify the formulation of the solver. In this paper we provide all the details to implement a fully ï¬‚edged rigid body solver that handles contacts, a variety of joint types and the interaction with soft objects. CCS Concepts â€¢ Computing methodologies â†’ Simulation by animation; Interactive simulation; Keywords: Rigid body simulation, soft body simulation, position based dynamics 1. Introduction Rigid body simulation lays at the heart of every game engine and plays a major role in computer generated special effects in movies. The central aspects of a rigid body simulation are contact and joint handling. Two popular approaches exist for collision handling, namely penalty methods and impulse based methods. Penalty meth- ods use forces caused by penetrating bodies for separation. These methods are rarely used in games and ï¬lms because large forces and small time steps are needed to make colliding bodies look rigid. Recently, penalty methods have gained popularity in connection with differentiable simulations because they generate smooth tra- jectories. The most popular approach is to use impulses, however. Mir- tich and Canny [MC95] laid the foundation for impulse based câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. Published by John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics ğ›»ğ¶2 ğ›»ğ¶1 ğ‘™2ğ‘™1 ğ‘™2ğ‘™1 ğ©1 ğ©2 ğ©2ğ©1 ğ©3 ğ©3 Figure 2: Non-linear Gauss-Seidel: Points ?1 and ?2 are ï¬xed to the ground. The distances from the top point ?3 to ?1 and ?2 are constrained to be ;1 and ;2 respectively. Finding a position for ?3 which satisï¬es both constraints is a non-linear positional problem. By working with velocities or by solving it globally the constraint gradients get ï¬xed. In these cases the red point above the true so- lution is found no matter how many iterations are applied. To ï¬nd the true solution, multiple linear solves have to be performed. A non-linear Gauss-Seidel solver works on the non-linear positional problem directly. It updates the gradients after each individual con- straint projection and converges to the true solution without the danger of overshooting. rigid bodies simulation in graphics and games in the mid nineties. Hecker [Hec97] introduced the concepts to game developers and Baraff [Bar97] to the computer graphics community. Here, the ve- locities are changed immediately at impacts by applying impulses instead of applying accelerations caused by forces. Conceptually, these methods work on the velocities directly omitting the acceler- ation layer. Simulating objects with dynamically changing positions and ori- entations is a non-linear problem. However, freezing a spatial con- ï¬guration and solving for velocities results in a linear system of equations. Contacts yield inequality constraints so in general, a lin- ear complementarity problem (LCP) has to be solved which is â€“ as the name indicates â€“ still linear. The space of velocities can be viewed as the tangent space to the non-linear space of spatial states at the current conï¬guration. Working within the linear space of ve- locities is therefore more convenient than working with positions and orientations directly. However, one of the main drawbacks of this approach is the problem of drift because a velocity solver does not see positional errors. Existing engines solve this problems with a variety of methods such as introducing additional forces or con- straints. Position based dynamics (PBD) [MHR06, Sta09] solves this problem by working with positions directly. Velocities are derived after the solve as the difference between the conï¬guration at the end and the beginning of the time step. PBD has mostly been used for the simulation of constrained par- ticle systems to simulate cloth and soft bodies until Macklin et al. [MM13] devised a way to handle ï¬‚uids as well. This allowed the development of a particle based uniï¬ed solver in the position based framework [MMCK14] by the same group. They used the idea of shape matching [MHTG05] to simulate rigid bodies as a collection of rigidly connected particles. However, the cost of shape matching grows with the number of particles, impulse propagation is slow and handling joints difï¬cult. A more effective way is to extend PBD beyond particles and simulate rigid bodies as single entities by introducing rotational states. Deul et al. [DCB14] formulated this type of rigid body dynamics in the positional framework of PBD. Working with velocities or linearizing the positional problem for an iteration of a global solver both have one aspect in common: they freeze the constraint directions for the time of the linear solve, i.e. over several iterations [MEMâˆ—19, ST96, KSJP08]. In this case, contacts have to be treated as local planes and coulomb friction cones as polyhedra. Also, constraints in three dimensions such as an attachment yield three constraint equations. In contrast, algo- rithms based on solving local contact problems with methods such as Gauss-Seidel allow contact geometry to change at each itera- tion. This approach has been used to model smooth isotropic fric- tion [Erl17, DBDB11]. We extend this approach to also allow con- tact normal geometry to change each iteration. The original PBD approach uses the non-linear projected Gauss- Seidel (NPGS) method to solve the non-linear positional equations. NPGS is fundamentally different from applying the regular or pro- jected Gauss-Seidel (PGS) method to the linearized equations. Fig- ure 2 visualizes this difference. The key is that after each individual constraint solve, the positions are immediately updated. In this way, PBD works on the non-linear problem directly, increasing both ro- bustness and accuracy. Round friction cones or collisions against curved objects are easy to handle. Instead of storing contacts as ref- erences to a pair of objects together with a static normal which re- sults to a contact plane, we only store the references and recompute the normal before every individual solve of the speciï¬c contact. A less expensive way would be to store the local contact geometry as in the traditional approach but using a higher-order approximation. Due to these advantages, our goal was to extend PBD in a way that allows the implementation of a fully ï¬‚edged rigid body engine but without sacriï¬cing its simplicity. We will provide all the algo- rithms on a level that allows an immediate implementation. However, PBD has had the reputation of being non-physical and too much of a simpliï¬cation based on the following concerns: â€¢ It does not use physical quantities and units â€¢ The stiffness is iteration and time step dependent â€¢ The integration is not physically accurate â€¢ It is dependent on the order of constraint handling â€¢ It depends on mesh tessellation â€¢ It converges slowly Fortunately, all these concerns have been addressed recently with the result that our proposed solver is a serious competitor to other methods as we will show in the results section. The ï¬rst three concerns have been addressed in [MMC16]. Ex- câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics tended PBD (XPBD) adds a small extension to the original ap- proach which makes stiffness independent of the iteration count and time step size with physical units and allows measuring forces and torques. The authors also show that XPBD is a close approxi- mation of implicit Euler integration. An important feature of XPBD is that compliance is used which is the inverse of stiffness. This means we can easily handle inï¬nitely stiff constraints in a robust way by setting the compliance to zero. In this case XPBD falls back to PBD. The solution returned from Gauss-Seidel methods is in general dependent on the ordering of the constraint solve. There are sit- uations in which this order dependence is valuable, for instance to control error propagation. However, the dependence can be re- moved by using Jacobi, or symmetric successive over relaxation (SSOR) iterations. PBD can also handle constraints that are based on continuum mechanics with common ï¬nite element (FEM) con- stitutive models [MMC16]. This alleviates the problem of mesh de- pendent stiffness present in more ad-hoc energy models. Finally, the concern regarding slow convergence was addressed most recently in [MSLâˆ—19]. By replacing solver iterations with substeps, Gauss-Seidel and Jacobi methods become competitors of global solvers in terms of convergence. Substepping in combina- tion with one NPGS iteration per substep yields a method that looks computationally almost identical to an explicit integration step, but with the advantage of being unconditionally stable due to the usage of compliance. We call it a quasi-explicit method. The ï¬ndings described in [MSLâˆ—19] about substepping are sur- prising and somewhat unintuitive. Substepping is not just the reduc- tion of the time step size. The important concept is the simulation time budget per frame which is typically constant in real-time appli- cations and given by the number of sub-steps times the number of solver iterations per substep. One extreme choice is to only use one substep and spend all the time budget with solving the equations to high accuracy. The other extreme is to use as many substeps as possible and only use a single iteration to solve the equations ap- proximately. The surprising fact which we will demonstrate in this paper as well is that the best choice in terms of accuracy of the simulation is to choose the maximum number of substeps with one iteration each. Substepping is not only optimal for accuracy, it also reveals high frequency temporal detail that is missed when using large time steps. Substepping also improves energy conservation signiï¬cantly and reduces the chances of missing collisions via tun- neling. Since using one iteration is the best choice in terms of accuracy, the number of substeps can be derived from the time budget and since we use XPBD which allows the use of true physical quanti- ties, there is no need to tune any parameters. Due to the uncondi- tional stability of XPBD, there is no need to tune the time step sizes for stability reasons either. 2. Related Work Rigid body simulation has a long history in computer graphics. For a comprehensive overview of the ï¬eld we refer the reader to the recent survey by Bender et al. [BET14]. It covers most of the im- portant work in this ï¬eld published since the state of the art report of Baraff [Bar93]. We have already mentioned most of the speciï¬c work that is closely related to our method in the introduction. Here we add a few more approaches to that list. Our method focuses on the handling of varying contact normals. To handle time-varying contact areas, Xu et al. [XZB14] proposed a simulation method based on semi-implicit integration. They use analytic contact gradients in connection with a penalty formulation. The stability is increased by using symbolic Gaussian elimination. To increase the ï¬delity of contact handling, Wang et al. [WSPJ17] precompute spatially and directionally varying restitution coefï¬- cients by treating a body as a stiff deformable object and solve a proxy contact problem. Using this data results in more realistic bouncing behavior during simulation. Implicit position-based time discretizations and constraints have been used in the computer-aided design (CAD) and multibody dy- namics software, such as ADAMS and MBDyn [OCC77, Rya90, MMM14]. They most often use penalty models of contact that re- quire carefully tuned parameters, and do not allow for perfectly hard contact response. Ofï¬‚ine multibody dynamics software may also use higher-order integration schemes such as second order implicit Euler (BDF2) that increase the accuracy of the simula- tion of objects in free ï¬‚ight. However, for non-smooth trajectories, typical situation in rigid body simulations with contact, we found higher-order integration may yield spurious and unpredictable col- lision response. This motivates our use of small time-steps and complementarity-based contact models. One of the advantages of our method is the natural handling of coupled simulations with rigid and soft bodies. Galvez et al. [GCCâˆ—] simulate the non-smooth dynamics of systems with rigid and deformable bodies by linking them with kinematic joints. The resulting contact problem is formulated using a mixed aug- mented Lagrangian method. The equations of motion are integrated with a non-smooth generalized-U time integration scheme. To handle rigid bodies, we augment the particles with orienta- tion information. MÃ¼ller et al. [MC11] used this idea to stabilize the simulation of soft objects via shape matching. Later Umetani et at. [USS15] leveraged the same idea to simulate position based elastic rods. The most closely related method to our approach is the work of Deul et al. [DCB14]. They developed a formulation of rigid body dynamics in the positional framework of PBD. Their ideas are for- mulated somewhat vaguely, however. An example is the short para- graph about joints which only discusses one joint type and does not address joint limits â€“ a central feature of rigid body engines. In the results section we will present various examples which rely on the handling of hard and soft joint limits. We also describe collision against rounded objects. A central difference is the use of XPBD instead of PBD which not only allows the use of physical param- eters but also allows the derivation of forces and torques at joints and contacts. 3. Position Based Rigid Body Simulation We ï¬rst recap the original position based simulation algorithm for constrained particle systems. câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics ğ‘š1 ğ‘š2 ğ‘š1 ğ‘š2 ğ‘š1, I1 ğ‘š2, I2 ğ‘š1, I1 ğ‘š2, I2 âˆ†ğ± âˆ†ğ± âˆ†ğ±1 âˆ†ğ±2 âˆ†ğ±1 âˆ†ğ±2 âˆ†ğª1 âˆ†ğª2 ğ«1 ğ«2 I1 I2 âˆ†ğª1 âˆ†ğª2 âˆ†ğª I1 I2 Figure 3: The basic correction operations. Top: traditional particle based PBD. A positional correction vector \u0001x is applied to a pair of particles. This correction is distributed among both particles proportional to their inverse mass to conserve linear and angular momentum. Middle: applying a positional correction to points r1 and r2 on a pair of rigid bodies results in a pair of positional corrections \u0001x1 and \u0001x2 applied to the centers of mass as well as a pair of rotational corrections \u0001q1 and \u0001q2 proportional to a combination of their inverse masses and inverse moments of inertia. Bottom: a rotational correction \u0001q is applied to two bodies â€“ in this case to align their orientations. The rotational correction is distributed among the two bodies proportional to their inverse moments of inertia while the centers of mass are not affected. 3.1. Particle Simulation Loop Algorithm 1 Position Based Particle Simulation while simulating do CollectCollisionPairs(); \u0011 â† \u0001C/numSubsteps; for numSubsteps do for = particles do xprev â† x; v â† v + \u0011 fext/<; x â† x + \u0011 v; end for numPosIters do SolvePositions(x1, . . . x=); end for = particles do v â† (x âˆ’ xprev)/\u0011; end end end Algorithm 1 shows the simulation loop. Here we already in- cluded the idea of substepping for which \u0001C is the time step size and \u0011 the substep size. During the ï¬rst loop of each substep, the particleâ€™s positions x8 and velocities v8 are explicitly integrated taking only the external forces fext such as gravity into account. The second loop implements the core implicit solver. The proce- dure \"SolvePositions\" iterates through all constraints (either Gauss- Seidel or Jacobi style) and moves the positions of the particles us- ing constraint projection. Discussing this part will be our main fo- cus. In the third loop the new velocities are derived from the previ- ous and current positions. Macklin et al. [MSLâˆ—19] showed that it is signiï¬cantly more effective to take substeps than solver iterations so \"numPosIters\" is typically set to 1. 3.2. Rigid Body Simulation Loop In contrast to a particle which is described by its position x, its velocity v and its mass < alone, the state of a rigid body of ï¬nite size also contains the corresponding angular quantities. These are â€¢ its orientation which can be described by a unit quaternion q âˆˆ R4, |q| = 1, â€¢ its angular velocity l âˆˆ R3 and â€¢ its inertia tensor I âˆˆ R3G3. The angular velocity vector can be split into the unit axis of ro- tation and the scalar angular velocity as 8 = l Â· nrot. (1) The inertia tensor I is the quantity that corresponds to the mass in rotational terms. For basic shapes like boxes and spheres it is given by simple formulas. Blow and Binstock [BB04] devised an elegant and short algorithm for the general case of a body that is described by a closed triangle mesh, which simultaneously computes the cen- ter of mass. Algorithm 2 shows the extended version of Algorithm 1 which take these additional quantities into account. câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics Algorithm 2 Position Based Rigid Body Simulation while simulating do CollectCollisionPairs(); \u0011 â† \u0001C/numSubsteps; for numSubsteps do for = bodies and particles do xprev â† x; v â† v + \u0011 fext/<; x â† x + \u0011 v; qprev â† q; l â† l + \u0011 Iâˆ’1 (gext âˆ’ (l Ã— (Il))); q â† q + \u0011 1 2 [lG, lH, lI, 0] q; q â† q/|q|; end for numPosIters do SolvePositions(x1, . . . x=, q1, . . . q=); end for = bodies and particles do v â† (x âˆ’ xprev)/\u0011; \u0001q â† q qâˆ’1 prev; 8 â† 2[\u0001qG, \u0001qH, \u0001qI]/\u0011; 8 â† \u0001@F â‰¥ 0 ? 8 : âˆ’8; end SolveVelocities(v1, . . . v=, l1, . . . l=); end end The additional lines for integrating the rotational quantities and deriving the velocities can easily be added to an existing PBD sim- ulator. The term for integrating angular velocity including external torques and gyroscopic effects is derived from the Newton-Euler equations. We refer the reader to Brian Mirtichâ€™s excellent the- sis [Mir96] for a derivation. To update the quaternions based on the angular velocity and to derive the angular velocity from the change of the quaternions we use linearized formulas. They are fast and robust and well suited for the small time steps used in substepping. In contrast to simple particles, the implicit solver also manipulates the orientations of the bodies. This position based solver allows the simultaneous and coupled simulation of both rigid and deformable objects. To achieve this we iterate through all bodies as well as all particles. For the particles we simply omit the updates of the rotational quantities. 3.3. Core Projection Operations The modiï¬cations to the main loop are straightforward. The chal- lenging part is the extension of the solver to handle constraints be- tween ï¬nite sized bodies in a positional framework. Fortunately we only need two basic operations. The tasks of solving arbitrary joints, handling contacts or coupling rigid with soft bodies can all be built on top of these operations alone. They are visualized in Figure 3. The top row shows a distance constraint between two particles as a reference. Here a correction vector \u0001x is applied to project the overstretched constraint to its rest length. To conserve linear momentum, the correction vector is applied to both parti- cles proportional to their inverse masses F8 = <âˆ’1 8 . The middle row shows the ï¬rst basic operation used for rigid bodies, namely applying a position correction \u0001x to solve a generalized distance constraint between points on two bodies. The points are deï¬ned by the vectors r1 and r2 relative to the center of mass. To conserve lin- ear and angular momentum, the operation changes the positions as well as the orientations of both bodies proportional to their general- ized inverse masses. The second operation is applying a rotational correction to two bodies as shown in the bottom row. In this partic- ular case, the correction is applied to align the orientations of the two bodies. To conserve angular momentum, it has to be distributed among the two bodies proportional to their inverse moments of in- ertia. We derive the formulas for the updates from impulse based dynamics in the Appendix. Here we show the ï¬nal versions to be used in an implementation. 3.3.1. Positional Constraints To apply a positional correction \u0001x at positions r1 and r2, we ï¬rst split it into its direction n and its magnitude 2. The latter corre- sponds to the evaluation of the constraint function in PBD. We then compute the two generalized inverse masses F1 â† 1 <1 + (r1 Ã— n)) Iâˆ’1 1 (r1 Ã— n) (2) F2 â† 1 <2 + (r2 Ã— n)) Iâˆ’1 2 (r2 Ã— n). (3) Following XPBD, we compute the Lagrange multiplier updates \u0001_ â† âˆ’2 âˆ’ ËœU _ F1 + F2 + ËœU (4) _ â† _ + \u0001_ (5) where ËœU = U/\u00112 and U the compliance of the constraint. One mul- tiplier _ is stored for each compliant constraint. It is set to zero be- fore the iterative solver starts. The compliance corresponds to the inverse of the stiffness and has the unit meters / Newton. Working with the compliance allows the simulation of inï¬nitely stiff con- straints by setting U = 0. Setting the positional impulse p = \u0001_n we update the states of the bodies immediately after each constraint solve via x1 â† x1 + p/<1 (6) x2 â† x2 âˆ’ p/<2 (7) q1 â† q1 + 1 2 [Iâˆ’1 1 (r1 Ã— p), 0] q1 (8) q2 â† q2 âˆ’ 1 2 [Iâˆ’1 2 (r2 Ã— p), 0] q2. (9) Note the minus sign in the update of the second body. Imme- diately updating the bodies after handling each constraint prevents overshooting and is one of the causes of PBDâ€™s robustness. This re- sults in a non-linear projected Gauss-Seidel solve. Alternatively a Jacobi solve can be used for parallel implementations or to remove the dependence on the order of constraint projection but at the cost of slower convergence. In this case, the updates are accumulated câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics and applied after each iteration through all constraints. After the solve, the forces acting along the constraint can be derived as f = _n/\u00112. (10) Connecting a rigid body and a soft body deï¬ned as a constrained particle system is straightforward because each body can be re- placed with a single particle by setting F â† <âˆ’1 and omitting the update of the orientation. 3.3.2. Angular Constraints For joints we need the ability to constrain the mutual orientation of two bodies. In this case the correction is a rotation vector \u0001q âˆˆ R3. We split it into its direction n which is the rotation axis and its magnitude \\ which is the rotation angle. The generalized inverse masses are F1 = n ) I âˆ’1 1 n (11) F2 = n ) I âˆ’1 2 n (12) The XPBD updates are the same as before with the angle replac- ing the distance \u0001_ â† âˆ’\\ âˆ’ ËœU _ F1 + F2 + ËœU (13) _ â† _ + \u0001_. (14) This time, the correction only affects the orientations as q1 â† q1 + 1 2 [Iâˆ’1 1 p, 0] q1 (15) q2 â† q2 âˆ’ 1 2 [Iâˆ’1 2 p, 0] q2. (16) It is important to note that the inertia tensor I depends on the ac- tual orientation of the body. Therefore, it would have to be updated after every constraint projection. Instead, we project the quantities n, r and p into the rest state of the bodies before evaluating the ex- pressions above. For joints, the attachment points r are typically deï¬ned in the rest state already. In addition, we rotate the bodies in the rest state such that the inertia tensor becomes diagonal which simpliï¬es the expressions above and allows storing the tensor as a vector. Analogous to Equation (10) we can derive the torque ex- erted as g = _n/\u00112. (17) 3.4. Joints We now describe how to handle joints of various types using the two correction operations deï¬ned in the previous section. Joints attach pairs of bodies and restrict relative positional and rotational degrees of the bodies. 3.4.1. Rotational Degrees of Freedom For a joint that aligns the mutual orientations of two bodies we compute the angular correction as follows: q = q1 q âˆ’1 2 (18) \u0001qï¬xed = 2(@ G, @ H, @I). (19) To setup more general joints, an attachment point Â¯r as well as a set of perpendicular unit axes [ Â¯a, Â¯b, Â¯c] have to be deï¬ned on both bodies in the shape. To handle the joint, these are ï¬rst transformed into world space vectors r and [a, b and c]. For a hinge joint, we want the axes a1 and a2 to be aligned. To achieve this we apply \u0001qhinge = a1 Ã— a2. (20) To drive a hinge joint towards a speciï¬ed target angle U we rotate b1 about a1 by then angle U to get btarget and apply \u0001qtarget = btarget Ã— b2. (21) The corresponding compliance U controls the stiffness of the con- straint. With a target angle constraint we can create a velocity driven motor by updating the target angle via U â† U + \u0011 E at ev- ery substep, where E is the target velocity of the motor and the corresponding compliance its strength. Handling joint limits is an essential part of a rigid body engine. For the rotational degrees of freedom this amounts to limiting joint angles. To do this we use the generic procedure deï¬ned in Algo- rithm 3. It limits the angle between the axes n1 and n2 of two bodies to be in the interval [U, V] using the common rotation axis n. Algorithm 3 Handling joint angle limits. LimitAngle (n, n1, n2, U, V): q â† arcsin((n1 Ã— n2) Â· n); if n1 Â· n2 < 0 then q â† c âˆ’ q; if q > c then q â† q âˆ’ 2c; if q < âˆ’c then q â† q + 2c; if q < U or q > V then q â† clamp(q, U, V); n1 â† rot(n, q) n1; Apply(\u0001qlimit = n1 Ã— n2); end return For hinge joints with common axis a1 = a2 we use [n, n1, n2] = [a1, b1, b2]. For spherical joints (also called ball-in-socket joints) we have to distinguish between swing and twist limits for the motion of axis a2 w.r.t. axis a1. To restrict swing we use [n, n1, n2] = [a1 Ã—a2, a1, a2]. Twist must be decoupled from swing. We achieve this with the fol- lowing axes: n â† (a1 + a2)/(|a1 + a2|) (22) n1 â† b1 âˆ’ (n Â· b1) n; n1 â† |n1| (23) n2 â† b2 âˆ’ (n Â· b2) n; n2 â† |n2| (24) câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics All limits can be made soft by using U > 0. 3.4.2. Positional Degrees of Freedom Handling the positional degrees of freedom is simpler. We ï¬rst compute the positional offset as \u0001r = r2 âˆ’ r1. Setting \u0001x = \u0001r at- taches the bodies without separation which is the typical case for joints. Using U > 0 allows the simulation of a spring with zero rest length. We can make this more ï¬‚exible by deï¬ning an upper limit 3max for the separation distance. In this case we only apply a cor- rection if |\u0001r| > 3max and use the correction \u0001x = \u0001r |\u0001r| (|\u0001r| âˆ’ 3max). (25) We can also relax the ï¬xed attachment by allowing the bodies to move within boundaries along a subset of the axes. For this we start with \u0001x = 0. For the ï¬rst axis a1 we compute the projected displacement 0 = \u0001r Â· a1. If 0 < 0min we add a1 (0 âˆ’ 0min) to the correction vector, if 0 > 0max we add a1 (0 âˆ’ 0max). We do this for all axes and all limits before we apply the ï¬nal correction vector. This way, all limits are treated with a single constraint projection. Setting all limits except the ones for the ï¬rst axis to zero simu- lates a prismatic joint. For a robot we might want to drive the joint to a particular offset. Replacing 3max by 3target in Eqn.(25) and applying the correction unconditionally achieves this. Choosing a compliance of U = 1/ 5 (|\u0001r| âˆ’ 3target) applies a force 5 . Joint handling shows the advantage of working on the positional layer with the non-linear Gauss-Seidel approach. Unilateral con- straints are simply handled by applying corrections only when cer- tain conditions hold. Also, the corrections are always aligned with the current offsets and errors. In addition, attachments are handled with a single constraint instead of three in linearized solvers. 3.5. Handling Contacts and Friction To save computational cost we collect potential collision pairs once per time step instead of once per sub-step using a tree of axis aligned bounding boxes. We expand the boxes by a distance : \u0001C Ebody, where : â‰¥ 1 is a safety multiplier accounting for poten- tial accelerations during the time step. We use : = 2 in our exam- ples. At each substep we iterate through the pairs checking for actual collisions. If a collision occurs we compute the current contact nor- mal and the local contact positions r1 and r2 with respect to body 1 and 2. We also initialize two Lagrange multipliers for the normal and tangential forces _= and _C with zero. To handle a contact dur- ing the position solve we compute the contact positions on the two bodies at the current state and before the substep integration as p1 = x1 + q1 r1 p2 = x2 + q2 r2 Â¯p1 = x1,prev + q1,prev r1 and Â¯p2 = x2,prev + q2,prev r2, (26) where the product of a quaternion and a vector refers to rotating the vector using the quaternion. The current penetration can be computed as 3 = (p1 âˆ’ p2) Â· n. If 3 â‰¤ 0 we skip the contact. The non-linear Gauss-Seidel solver lets us handle the complementarity condition by simply checking it on a per constraint basis. If the bodies are penetrating we apply \u0001x = 3n using U = 0 and _=. To handle static friction we compute the relative motion of the contact points and its tangential component \u0001p = (p1 âˆ’ Â¯p1) âˆ’ (p2 âˆ’ Â¯p2) (27) \u0001pC = \u0001p âˆ’ (\u0001p Â· n)n. (28) Static friction prevents tangential motion at the contact points which is the case if \u0001pC = 0. Therefore, to enforce static friction we apply \u0001x = \u0001pC at the contact points with U = 0 but only if _C < `B_=, where `B is the static friction coefï¬cient. If the two bodies have different coefï¬cients, we use ` = (`1 + `2)/2. Another option would be to take the maximum or minimum value. 3.6. Velocity Level PBD updates the velocities after the position solve and then im- mediately goes to the next substep. However, to handle dynamic friction and restitution we append a velocity solve as shown in Al- gorithm 2. Here we iterate once through all the contacts and update the new velocities. For each contact pair we compute the relative normal and tan- gential velocities at the contact point as v â† (v1 + l1 Ã— r1) âˆ’ (v2 + l2 Ã— r2) E= â† n Â· v (29) vC â† v âˆ’ n E=. The friction force is integrated explicitly by computing the ve- locity update \u0001v â† âˆ’ vC |vC | min(\u0011 `3 | 5= |, |vC |), (30) where `3 is the dynamic friction coefï¬cient and 5= = _=/\u00112 the normal force. This update corresponds to the explicit application of the dynamic Coulomb friction force. The explicit form in connec- tion with a Gauss-Seidel update allows us to make this step uncon- ditionally stable! The minimum guarantees that the magnitude of the velocity correction never exceeds the magnitude of the velocity itself. We also use the velocity pass to apply joint damping via \u0001v â† (v2 âˆ’ v1) min(`lin\u0011, 1) (31) \u0001l â† (l2 âˆ’ l1) min(`ang\u0011, 1). (32) According to the derivation in the Appendix applying a velocity update \u0001v at positions r1 and r2 is achieved by the following steps: p = \u0001v F1 + F2 v1 â† v1 + p/<1 v2 â† v2 âˆ’ p/<2 81 â† 81 + Iâˆ’1 1 (r1 Ã— p) 82 â† 82 âˆ’ Iâˆ’1 2 (r2 Ã— p). (33) câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics Example substeps iters/substep time (ms/frame) 3 Boxes 20 1 0.34 7 Boxes 20 1 0.44 Pendula 40 1 0.07, 0.09, 0.2 Bunnies 20 1 2.3 Rolling balls 10 1 15 Coin 20 1 0.3 Car 20 1 18 Robot 20 1 0.4 Rope 20 1 3.5 Table 1: Computation times. We used a simulation time step of 1/60s per frame in all cases. To handle restitution we also need Â¯E=, the normal velocity before the PBD velocity update. We compute this quantity by applying Eqn 29 to the pre-update velocities. Given the restitution coefï¬- cient 4 we want the normal velocity at the contact to be âˆ’4 Â¯E=. By applying \u0001v â† n(âˆ’E= + min(âˆ’4 ËœE=, 0)), (34) we subtract the current velocity E= and replace it with the reï¬‚ected velocity âˆ’4 Â¯E= making sure that the resulting velocity points in the direction of the collision normal. To avoid jittering we set 4 = 0 if |E= | is small. We use a threshold of |E= | â‰¤ 2|g|\u0011, where g is gravity. This value corresponds to two times the velocity the prediction step adds due to gravitational acceleration. This step also alleviates an important problem of PBD. The ve- locities created by the regular velocity update step of PBD are only meaningful if no collisions have occured during the last time step. Otherwise they simply reï¬‚ect the penetration depth which is de- pendent on the time discretization of the trajectory. Also, if objects are created in an overlapped state, PBD yields large separating ve- locities. Eqn (34) eliminates the derived velocity at an impact and replaces it with the one from the previous time step considering the restitution coefï¬cient. In the case of initially overlapping objects, this velocity is zero. 4. Results For our demos we used a system with a Core-i7 CPU at 3.6 GHz and 32 GB of RAM. Table 1 shows the simulation times per frame for the various examples. The capabilities and performance of our method are best seen in the accompanying video. We will ï¬rst discuss a few basic technical scenarios that we performed with our test application. The appli- cation allows the visualization of forces, torques and elongations at the joints. Figure 4 shows a set of boxes which are attached to the static ceiling via distance joints. All springs have compliance 0.01</#. The larger and smaller boxes have masses 1 and 1/8kg, respectively and we set gravity to 10</B2. The simulation yields the correct elongations and forces independent of the number of iterations and sub-steps. The same holds for joint torques. Figure 5 shows a bar that is attached via a hinge joint which has a target angle of zero degrees Figure 4: Our test application allows the visualization of forces, torques and elongations dynamically. Compliance, forces and elon- gation are in the correct relation independent of the substep and iteration counts. Figure 5: The yellow line shows a spring with a ï¬xed compliance that is attached to the mouse. This bar is attached on the left via a hinge joint that has a target angle of zero with zero compliance. The joint applies the correct torque to hold the bar straight. with zero compliance. It exerts the correct torque to counteract the force that is applied by the user a distance of 202< away from the rotation center. With XPBD it is straightforward to specify an inï¬nitely stiff joint by setting the compliance to zero which is not the case for force or impulse based systems. Figure 6 shows an experiment with large mass ratios. A small box of one gram is attached to the static ceiling via a distance joint. Below it hangs a heavy box of one kilogram attached via an- other distance joint. The experiment is duplicated with compliances 0.01, 0.001 and 0</#. Our method handles this situation stably. In the case of non-zero compliance, the distances are proportional to the forces. In the case of zero compliance the distance remains zero independent of the force. With 20 substeps a small error at the top joint remains. In Figure 7 we show prismatic, hinge and ball-in-socket joint with various joint limits and target angles and target offsets. With simple hinge joints it is possible to reproduce the behavior of a dou- ble, a triple and a closed loop pendulum as shown in Figure 8. The typical chaotic motion only emerges with small time steps and a small amount of damping. With 40 substeps and one iteration the pendula keep on swinging for a long time. Using 1 substep but an arbitrary number of solver iterations - 100 in our example - the pen- dula come to rest very quickly. Figure 9 shows the evolution of the câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics Figure 6: Handling large mass ratios: A small box of 1 gram is attached to the ceiling via a distance constraint and holds a box of 1 kilogram via a second joint. The compliances of the joints are from left to right 0.01, 0.001 and 0 m/N. Figure 7: With our method we can create a variety of joint types with target angles and soft and hard joint limits. Figure 8: Substepping yields the correct behavior of the double and triple pendula. We can easily simulate a closed loop pendulum as well.Energy Time (s) 0 1 2 3 4 5 6 7 8 9 10 20 x 1 10 x 2 5 x 4 2 x 10 1 x 20 Figure 9: Energy conservation during the simulation of the triple pendulum dependent on the number of substeps and solver itera- tions. Figure 10: The simulation of a chain of 100 bunnies hanging from the ceiling demonstrates the effectiveness of substepping. Left: 1 substep, 20 iterations, right: 20 substeps, 1 iteration. energy during the simulation of the triple pendulum dependent on the number of substeps and solver iterations. As discussed before, the best choice is to replace all solver iterations by substeps. To verify that this is the case for constraint errors as well, we created a chain of 100 bunnies hanging from the ceiling as shown in Figure 10. We tested a variety of substep and iteration count combinations for a ï¬xed time budget. Figure 11 shows the relativeElongation (%) Substeps x Iterations 0% 20 x 1 10 x 2 5 x 4 2 x 10 1 x 20 10% 20% 30% Figure 11: Elongation of the bunny chains dependent on the num- ber of substeps and solver iterations câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics Figure 12: From top to bottom: Initial condition, after the hit of the red marble using our velocity pass and a restitution of 1 and the state resulting from the regular PBD velocity derivation. Figure 13: The marbles are created penetrating the wires. Top: Regular PBD creates large velocities causing the marbles to jump off the track. Bottom: The marbles are pushed up gently and remain on the track. elongation of the chain for each case. Again, replacing all solver iterations by substeps is by far the best choice. The accompanying video shows the impressive difference in behavior. The velocity pass we described in Section 3.6 yields proper im- pulse propagation as shown in Figure 12. Here a single marble hits a group of three marbles from the right. The impulse is correctly transferred to the right most marble as shown in the middle. The bottom image shows the situation after the hit when using the ve- locity derivation of PBD. In the scene shown in Figure 13 the marbles penetrate the wires in the initial state. The velocity derivation of PBD yields large ve- locities causing the marbles jumping off the track (top image) while they stay on the track with our method (bottom image). We created two larger scenes tailored to demonstrate the advan- tages of our method: a rolling ball sculpture and a remote controlled car travelling over bumpy terrain and obstacles shown in Figure 1. The rolling ball demo is an attempt to reproduce the fascinat- ing sculptures of David Morell [Mor] including the clever mecha- nisms in a simulation. In certain elements such as the spring shown in Figure 14 the marbles perform a quarter turn in a single time step. Simulating such fast curved motions requires substepping and the use of current constraint normals for each projection. Here, the most expensive part is collision handling, in particular ï¬nding the closest point on a Hermite spline segment. Our method also allows us to reproduce the high frequency motion of a coin before it comes to rest as shown in Figure 15. Figure 14: In certain elements of the sculpture the marbles perform large turns in a single time step which requires the use of current constraint directions for each projection. Figure 15: With the ability of handling curved geometry and sub- stepping we are able to reproduce the high frequency motion of a coin shortly before it comes to rest. The simulation of the remote controlled car demonstrates how our method handles the coupling of the soft body tires with the rigid rims. It also shows how well sub-stepping handles large mass ratios. We simulate the entire steering mechanism from servo to wheels as shown in Figure 16. The mass ration between the servo arm and the wheels is 1:760. The servo arm is 3cm long while the wheels have a diameter of 15cm. Nevertheless, the servo motor is strong enough to turn the big wheels at high speed against the obstacles and the terrain. Using actual constraint directions is important because a remote controlled car experiences much higher accelerations and changes in direction than a regular car. Our method also resolves the high frequency vibrations giving the feel for the high stiffness of the springs. The most expensive part is the simulation of the wheels. We have found that using FEM on tetrahedra did not yield the stiffness needed within the time budget. Instead, we perform Figure 16: We simulate the steering mechanism from the small arm at the servo to the big wheels with a mass ratio of 1:760. câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics Figure 17: Our method can be used to solve inverse kinematics problems for overconstrained systems with possibly redundant de- grees of freedom such as this robot arm. Figure 18: The separate handling of swing and twist limits allows the simulation of a twisted rope. per element shape matching [MHTG05] on the 1100 hexahedral elements of the tires. Finally we created two scenarios to show the importance and usefulness of joint limit handling. Figure 17 shows that our method can be used to solve the inverse kinematic problem to make the robot gripper following the gray box while respecting all joint lim- its. Unreachable positions yield overconstrained problems which our method handles gracefully by moving the gripper as close as possible to the target pose. Our method allows the user to spec- ify independent limits on swing and twist degrees of freedom with different compliances. This allows us to simulate the twisted rope shown in Figure 18 with the correct behavior as a simple chain of 100 capsules connected by spherical joints. 5. Conclusion We have presented a rigid body simulation method than can ac- curately resolve small temporal and spatial detail. Because it is based on XPBD, it inherits XPBDâ€™s simplicity and ability to handle inï¬nitely stiff joints. Substepping increases accuracy and energy conservation. It also allows the handling of large mass ratios and fast directional changes within a single time step. We have shown that two basic projection operations are sufï¬cient to build a fully ï¬‚edged rigid body engine in a straightforward way. For snippets of source code we refer the reader to our challenges page [Mue20]. A drawback of substepping is that it does not damp out high frequency vibrations due to reduced numerical damping. This can yield visual jittering. However, numerical damping can easily be reintroduced by adding true physical damping. Also, for small time steps, double precision ï¬‚oating point numbers are required. While doubles are as fast as ï¬‚oats on CPUs, they currently still reduce the performance on GPUs. Updating constraint directions after each projection might cause instabilities when simulating tall stacks or piles of objects. Investigating this problem is one of our directions of future work. References [Bar93] BARAFF D.: Non-penetrating rigid body simulation. State of the art reports (1993). 3 [Bar97] BARAFF D.: An introduction to physically based modeling: Rigid body simulation. In SIGGRAPH â€™97 Course Notes (1997). 2 [BB04] BLOW J., BINSTOCK A.: How to ï¬nd the inertia tensor (or other mass properties) of a 3d solid body represented by a triangle mesh. 4 [BET14] BENDER J., ERLEBEN K., TRINKLE J.: Interac- tive simulation of rigid body dynamics in computer graph- ics. Computer Graphics Forum 33, 1 (2014), 246â€“270. URL: https://onlinelibrary.wiley.com/doi/abs/10.1111/ cgf.12272, arXiv:https://onlinelibrary.wiley.com/ doi/pdf/10.1111/cgf.12272, doi:10.1111/cgf.12272. 3 [DBDB11] DAVIET G., BERTAILS-DESCOUBES F., BOISSIEUX L.: A hybrid iterative solver for robustly capturing coulomb friction in hair dy- namics. In ACM Transactions on Graphics (TOG) (2011), vol. 30, ACM, p. 139. 2 [DCB14] DEUL C., CHARRIER P., BENDER J.: Position-based rigid body dynamics. Computer Animation and Virtual Worlds 27, 2 (2014), 103â€“112. URL: http://dx.doi.org/10.1002/cav.1614, doi:10.1002/cav.1614. 2, 3 [Erl17] ERLEBEN K.: Rigid body contact problems using proximal op- erators. In Proceedings of the ACM Symposium on Computer Animation (2017), p. 13. 2 [GCCâˆ—] GALVEZ J., CAVALIERI F. J., COSIMO A., BRÃœLS O., CARDONA A.: A nonsmooth frictional contact formu- lation for multibody system dynamics. International Jour- nal for Numerical Methods in Engineering n/a, n/a. URL: https://onlinelibrary.wiley.com/doi/abs/10.1002/ nme.6371, arXiv:https://onlinelibrary.wiley.com/ doi/pdf/10.1002/nme.6371, doi:10.1002/nme.6371. 3 [Hec97] HECKER C.: The third dimension. Game Developer Mag- azine (June 1997). URL: chrishecker.com/Rigid_Body_ Dynamics. 2 [KSJP08] KAUFMAN D. M., SUEDA S., JAMES D. L., PAI D. K.: Stag- gered projections for frictional contact in multibody systems. In ACM Transactions on Graphics (TOG) (2008), vol. 27, ACM, p. 164. 2 [MC95] MIRTICH B., CANNY J.: Impulse-based simulation of rigid bod- ies. In Proceedings of the 1995 Symposium on Interactive 3D Graphics (New York, NY, USA, 1995), I3D â€™95, Association for Computing Ma- chinery, p. 181â€“ff. URL: https://doi.org/10.1145/199404. 199436, doi:10.1145/199404.199436. 1 [MC11] MÃœLLER M., CHENTANEZ N.: Solid simulation with oriented câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd. M. MÃ¼ller et al. / Detailed Rigid Body Simulation with Extended Position Based Dynamics particles. ACM Trans. Graph. 30, 4 (July 2011). URL: https://doi. org/10.1145/2010324.1964987, doi:10.1145/2010324. 1964987. 3 [MEMâˆ—19] MACKLIN M., ERLEBEN K., MÃœLLER M., CHENTANEZ N., JESCHKE S., MAKOVIYCHUK V.: Non-smooth newton methods for deformable multi-body dynamics. ACM Trans. Graph. 38, 5 (Oct. 2019). URL: https://doi.org/10.1145/3338695, doi:10. 1145/3338695. 2 [MHR06] MÃœLLER M., HENNIX B. H. M., RATCLIFF J.: Position based dynamics. Proceedings of Virtual Reality Interactions and Physical Sim- ulations (2006), 71â€“80. 2 [MHTG05] MÃœLLER M., HEIDELBERGER B., TESCHNER M., GROSS M.: Meshless deformations based on shape matching. ACM Trans. Graph. 24, 3 (July 2005), 471â€“478. URL: https://doi. org/10.1145/1073204.1073216, doi:10.1145/1073204. 1073216. 2, 11 [Mir96] MIRTICH B. V.: Impulse-based Dynamic Simulation of Rigid Body Systems. PhD thesis, 1996. AAI9723116. 5 [MM13] MACKLIN M., MÃœLLER M.: Position based ï¬‚uids. ACM Trans. Graph. 32, 4 (July 2013). URL: https://doi.org/10.1145/ 2461912.2461984, doi:10.1145/2461912.2461984. 2 [MMC16] MACKLIN M., MÃœLLER M., CHENTANEZ N.: Xpbd: Position-based simulation of compliant constrained dynamics. In Pro- ceedings of the 9th International Conference on Motion in Games (New York, NY, USA, 2016), MIG â€™16, Association for Computing Machin- ery, p. 49â€“54. URL: https://doi.org/10.1145/2994258. 2994272, doi:10.1145/2994258.2994272. 2, 3 [MMCK14] MACKLIN M., MÃœLLER M., CHENTANEZ N., KIM T.-Y.: Uniï¬ed particle physics for real-time applications. ACM Trans. Graph. 33, 4 (July 2014). URL: https://doi.org/10.1145/2601097. 2601152, doi:10.1145/2601097.2601152. 2 [MMM14] MASARATI P., MORANDINI M., MANTEGAZZA P.: An Ef- ï¬cient Formulation for General-Purpose Multibody/Multiphysics Anal- ysis. Journal of Computational and Nonlinear Dynamics 9, 4 (07 2014). 041001. URL: https://doi.org/10.1115/1.4025628, doi:10.1115/1.4025628. 3 [Mor] MORRELL D.: Rolling ball sculptures. URL: https://www. rollingballsculpture.com.au. 10 [MSLâˆ—19] MACKLIN M., STOREY K., LU M., TERDIMAN P., CHEN- TANEZ N., JESCHKE S., MÃœLLER M.: Small steps in physics simula- tion. In Proceedings of the 18th Annual ACM SIGGRAPH/Eurographics Symposium on Computer Animation (New York, NY, USA, 2019), SCA â€™19, Association for Computing Machinery. URL: https://doi. org/10.1145/3309486.3340247, doi:10.1145/3309486. 3340247. 3, 4 [Mue20] MUELLER M.: Web page, 2020. URL: matthiasmueller. info/challenges/challenges.html. 11 [OCC77] ORLANDEA N., CHACE M. A., CALAHAN D. A.: A sparsity- oriented approach to the dynamic analysis and design of mechanical sys- temsâ€”part 1. 3 [Rya90] RYAN R.: Adamsâ€”multibody system analysis software. In Multibody systems handbook. Springer, 1990, pp. 361â€“402. 3 [ST96] STEWART D. E., TRINKLE J. C.: An implicit time-stepping scheme for rigid body dynamics with inelastic collisions and coulomb friction. International Journal for Numerical Methods in Engineering 39, 15 (1996), 2673â€“2691. 2 [Sta09] STAM J.: Nucleus: Towards a uniï¬ed dynamics solver for computer graphics. In Computer-Aided Design and Computer Graph- ics, 2009. CAD/Graphicsâ€™ 09. 11th IEEE International Conference on (2009), IEEE, pp. 1â€“11. 2 [USS15] UMETANI N., SCHMIDT R., STAM J.: Position-based elastic rods. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation (Goslar, DEU, 2015), SCA â€™14, Eurographics Association, p. 21â€“30. 3 [WSPJ17] WANG J.-H., SETALURI R., PAI D. K., JAMES D. L.: Bounce maps: An improved restitution model for real-time rigid-body impact. ACM Transactions on Graphics (Proceedings of SIGGRAPH 2017) 36, 4 (July 2017). doi:https://doi.org/10.1145/ 3072959.3073634. 3 [XZB14] XU H., ZHAO Y., BARBI Ë‡C J.: Implicit multibody penalty- baseddistributed contact. IEEE Transactions on Visualization and Com- puter Graphics 20, 9 (2014), 1266â€“1279. 3 Appendix A: Appendix Derivation of the Position Based Updates In impulse based rigid body solvers, impulses are applied to bodies to change velocities at contact points. Let r be the vector from the center of mass to the contact point. Applying an impulse p at the contact point has two effects. It changes the velocity vcm of the center of mass and the angular velocity l of the body via p = < \u0001vcm (35) r Ã— p = I \u0001l, (36) where < and I are the mass and the moment of inertia of the body, respectively. The velocity at the contact point is v = vcm + l Ã— r. (37) Given the contact normal n we can express both the impulse and the velocity change along the normal as scalars and derive a rela- tionship between the two as follows: \u0001E = [\u0001vcm + \u0001l Ã— r] Â· n (38) = [p <âˆ’1 + (Iâˆ’1 (r Ã— p)) Ã— r] Â· n (39) = ? [n <âˆ’1 + (Iâˆ’1 (r Ã— n)) Ã— r] Â· n (40) = ? [n Â· n <âˆ’1 + (Iâˆ’1 (r Ã— n)) Ã— r Â· n] (41) = ? [<âˆ’1 + (r Ã— n)) Iâˆ’1 (r Ã— n)] (42) = ? F, (43) where F can be interpreted as a generalized inverse mass. Apply- ing an impulse ? at the contact point between two bodies yields a total velocity change of \u0001E = \u0001E1 + \u0001E2 = ?(F1 + F2). In other words, we can change the velocity at the contact point by applying an impulse ? = \u0001E/(F1 + F2). Once the impulse is known, we can compute the change of vcm and l as via \u0001vcm = p <âˆ’1 (44) \u0001l = Iâˆ’1 (r Ã— p). (45) To go from the velocity to the positional level, we conceptually multiply these equations by time. This turns the velocity correction \u0001v into a positional correction \u0001x and the impulse into a quan- tity of the unit mass times distance. The deï¬nition of the general- ized mass is unchanged. The update of the velocity of the center of mass turns into an update of the position of the center of mass. The update of the angular velocity turns into a rotation. To apply the ro- tation to the orientations we use the linearized quaternion updates from Algorithm 2. câƒ 2020 The Author(s) Computer Graphics Forum câƒ 2020 The Eurographics Association and John Wiley & Sons Ltd.","libVersion":"0.2.2","langs":""}